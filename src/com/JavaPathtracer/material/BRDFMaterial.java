package com.JavaPathtracer.material;

import java.util.List;
import java.util.concurrent.ThreadLocalRandom;

import com.JavaPathtracer.Light;
import com.JavaPathtracer.Pathtracer;
import com.JavaPathtracer.geometry.Hit;
import com.JavaPathtracer.geometry.Ray;
import com.JavaPathtracer.geometry.Sphere;
import com.JavaPathtracer.geometry.Vector;
import com.JavaPathtracer.scene.Scene;
import com.JavaPathtracer.scene.SimpleObject;
import com.JavaPathtracer.scene.Sun;

public abstract class BRDFMaterial extends BaseMaterial {

	public BRDFMaterial(Sampleable color) {
		super(color);
	}

	// BRDF
	public abstract double BRDF(Vector incident, Vector outgoing, Vector normal, Vector textureCoordinates);
	
	// sampler
	// TODO: use cosine weighted or even low-discrepancy sampling - both are faster to draw from AND have better distribution
	public Vector sample(Vector incident, Hit hit) {
		return Vector.uniformInHemisphere();
	}
	
	// PDF of the sampler (which does not necessarily draw from the BRDF - by default, do fully random sampling)
	public double samplerPDF(Vector incident, Vector outgoing, Vector normal) {
		return 1;
	}
	
	// should light sampling be attempted with this material?
	// TODO: more fine grained control (i.e. MIS)
	public abstract boolean sampleLights();
	
	// ---- mathy code incoming
	
	// generate a ray towards the light sample
	// TODO: implement solid angle sampling and destroy this hideous abomination
	public Ray getLightSampleRay(Hit hit, SimpleObject object) {
		
		// get the sphere which surrounds the light
		Sphere bounding = object.shape.getBoundingBox().toSphere();
		Vector towardsOrigin = bounding.center.minus(hit.point).normalize();
		
		// light sample rays are generated by picking random points on a disc centered on the light's bounding sphere and facing towards the hitpoint
		// pick random point on disc by picking a random rotation and distance from center
		double rotation = ThreadLocalRandom.current().nextDouble() * 2 * Math.PI;
		
		// generate a random vector on the disc - this step is easy since it's done in the plane of the disc
		Vector randomOnDisc = new Vector(Math.cos(rotation), 0, Math.sin(rotation)).times(ThreadLocalRandom.current().nextDouble() * bounding.radius);
		
		// transform the disc vector to world space
		Vector bvx = towardsOrigin.getOrthagonal();
		Vector bvy = towardsOrigin;
		Vector bvz = bvx.cross(bvy);
		
		// offset from the center of the disc to get the final point
		Vector worldPos = bounding.center.plus(randomOnDisc.fromCoordinateSpace(bvx, bvy, bvz));

		// return ray pointing at our final point
		return new Ray(hit.point, worldPos.minus(hit.point).normalize());
		
	}
	
	public Vector sampleLights(Hit hit, Scene scene) {
		
		// for each light...
		Vector sum = new Vector();
		List<SimpleObject> lights = scene.getLights();
		
		for(Light light: lights) {

			// get importance-generated ray
			Sphere bounding = light.getBoundingSphere();
			Ray ray = getISRay(hit, light);
			
			Hit lightHit = scene.traceRay(ray, light.object);
			if(lightHit != null) {
			
				// calculate solid angle
				// solid angle = 2pi(1 - cos(alpha)) where alpha = angle between disc center, edge as seen by hitpoint
				// avoid the need for an expensive arctangent
				double dist = bounding.center.minus(hit.point).length();
				double hypot = Math.sqrt(dist * dist + bounding.radius * bounding.radius);
				double solidAngle = 2 * Math.PI * (1 - dist / hypot);
				Vector irradiance = light.material.color.sample(lightHit.textureCoordinates.x, lightHit.textureCoordinates.y).times(solidAngle / (2 * Math.PI));
				
				double cosFactor = ray.direction.dot(hit.normal);
				sum.iadd(irradiance.imul(cosFactor).imul(BRDF(hit.ray.direction.reversed(), ray.direction, hit.normal, hit.textureCoordinates)));
			
			}
			
		}
		
		return sum;
		
	}

	public Vector sampleSun(Hit hit, Scene scene) {
		
		Sun sun = scene.getSun();
		
		if(sun == null) return Vector.ZERO;
		
		// dirty, but works..
		double dist = Math.random() * sun.radius;
		double angle = Math.random() * 2 * Math.PI;
		Vector inPlane = new Vector(Math.cos(angle) * dist, 0, Math.sin(angle) * dist);
	
		Vector bvx = sun.direction.getOrthagonal().normalize();
		Vector bvz = sun.direction.cross(bvx);
		Vector dir = sun.direction.plus(Vector.localToWorldCoords(inPlane, bvx, sun.direction, bvz)).normalize();
		
		Ray ray = new Ray(hit.point, dir);
		if(scene.traceSkyRay(ray)) {
			return sun.color.times(dir.dot(hit.normal)).imul(BRDF(hit.ray.direction.reversed(), dir, hit.normal, hit.textureCoordinates));
		}
		
		return Vector.ZERO;
		
	}
	
	@Override
	public Vector shade(Hit hit, int bounces, Scene scene, Pathtracer pathtracer, double ior) {
		
		boolean samplingLights = sampleLights();

		Ray next = new Ray(hit.point, sample(hit.ray.direction, hit));
		Vector recursive = pathtracer.pathtraceRay(scene, next, bounces + 1, !samplingLights, ior);
		Vector result = recursive.times(BRDF(hit.ray.direction.reversed(), next.direction, hit.normal, hit.textureCoordinates) / PDF(hit.ray.direction, next.direction, hit.normal)).times(next.direction.dot(hit.normal));

		if(samplingLights) {
			result.iadd(sampleLights(hit, scene));
			result.iadd(sampleSun(hit, scene));
		}
		
		Vector color = this.getColor(hit.textureCoordinates.x, hit.textureCoordinates.y);
		return result.times(color);
		
	}
	
}