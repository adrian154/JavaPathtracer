package com.JavaPathtracer.material;

import com.JavaPathtracer.geometry.Hit;
import com.JavaPathtracer.geometry.Vector;
import com.JavaPathtracer.pattern.Sampleable;

public class MirrorMaterial extends BRDFMaterial {

	public MirrorMaterial(Sampleable color) {
		super(color, false);
	}
	
	public MirrorMaterial() {
		this(new Vector(1.0, 1.0, 1.0));
	}

	// the mirror BRDF presents a bunch of numerical problems
	// things are simplified by the fact that BRDF() will only ever be used for rays generated by our sampler, which is the reflection direction
	// so we use the BRDF to cancel out the cosine term
	public double BRDF(Hit hit, Vector outgoing) {
		return 1 / outgoing.dot(hit.normal);
	}
	
	// general-use reflect function
	public static Vector reflect(Vector normal, Vector incident) {
		return incident.minus(normal.times(2 * normal.dot(incident)));
	}
	
	public Vector sample(Vector incident, Hit hit) {
		return MirrorMaterial.reflect(hit.normal, incident);
	}
	
	// *definitely* shouldn't try to sample lights for mirrors :)
	public boolean sampleLights() {
		return false;
	}
	
	@Override
	public boolean shouldImportanceSample() {
		return false;
	}
	
	@Override
	public String toString() {
		return String.format("Mirror %s", color.toString());
	}
	
}
